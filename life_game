// Conway's Game of Life (p5.js) â€” Gosper Glider Gun + UI + Grid Lines + é™æ­¢åˆ¤å®š
// 2025-10ç‰ˆ: UIå¼·åŒ–ãƒ»é€Ÿåº¦èª¿æ•´ãƒ»1ä¸–ä»£é€ã‚Šãƒ»ãƒªã‚»ãƒƒãƒˆãƒ»é™æ­¢çŠ¶æ…‹æ¤œå‡º

let cols = 100, rows = 100;
let scaleFactor = 4;
let grid, nextGrid;
let running = true;
let generation = 0;

// é€Ÿåº¦åˆ¶å¾¡
let ups = 10, minUPS = 1, maxUPS = 60;
let accumulatorMs = 0, lastMillis = 0;

// UI
let sliderUPS, labelUPS, btnPlayPause, btnStep, btnReset, labelGen, labelStatus;

// å‰ä¸–ä»£æ¯”è¼ƒç”¨
let prevHash = "";

function setup() {
  createCanvas(cols * scaleFactor, rows * scaleFactor);
  pixelDensity(1);
  initGrids();
  placeGosper(grid, 20, 20);
  createUI();
  lastMillis = millis();
}

function draw() {
  background(255);
  drawGrid();

  ups = sliderUPS.value();
  labelUPS.html(`é€Ÿåº¦ï¼š${nf(ups, 1, 0)} ä¸–ä»£/ç§’`);
  labelGen.html(`ä¸–ä»£ï¼š${generation}`);

  const now = millis();
  const dt = now - lastMillis;
  lastMillis = now;

  if (running) {
    accumulatorMs += dt;
    const interval = 1000.0 / ups;
    while (accumulatorMs >= interval) {
      const changed = stepOnce();
      accumulatorMs -= interval;
      // é™æ­¢åˆ¤å®š
      if (!changed) {
        running = false;
        labelStatus.html("ğŸŸ¢ é™æ­¢çŠ¶æ…‹ã«åˆ°é”");
      } else {
        labelStatus.html("");
      }
    }
  }
}

function initGrids() {
  grid = make2D(rows, cols, 0);
  nextGrid = make2D(rows, cols, 0);
  generation = 0;
  accumulatorMs = 0;
  prevHash = "";
}

function drawGrid() {
  // ã‚»ãƒ«æç”»
  noStroke();
  fill(20);
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (grid[y][x]) {
        rect(x * scaleFactor, y * scaleFactor, scaleFactor, scaleFactor);
      }
    }
  }

  // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆè–„ç°ï¼‰
  stroke(220);
  strokeWeight(1);
  for (let x = 0; x <= cols; x++) {
    line(x * scaleFactor, 0, x * scaleFactor, height);
  }
  for (let y = 0; y <= rows; y++) {
    line(0, y * scaleFactor, width, y * scaleFactor);
  }
}

function stepOnce() {
  let changed = false;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      let n = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const yy = y + dy, xx = x + dx;
          if (yy >= 0 && yy < rows && xx >= 0 && xx < cols) n += grid[yy][xx];
        }
      }
      const alive = grid[y][x] === 1;
      const next = (alive && (n === 2 || n === 3)) || (!alive && n === 3) ? 1 : 0;
      nextGrid[y][x] = next;
      if (next !== grid[y][x]) changed = true;
    }
  }

  // ãƒãƒƒã‚·ãƒ¥ã§å‰å›ã¨æ¯”è¼ƒã—ã¦ã‚‚å¤‰åŒ–ãŒãªã„å ´åˆã¯åœæ­¢ï¼ˆæŒ¯å‹•å¯¾ç­–ï¼‰
  const newHash = hashGrid(nextGrid);
  if (newHash === prevHash) changed = false;
  prevHash = newHash;

  let tmp = grid; grid = nextGrid; nextGrid = tmp;
  generation++;
  return changed;
}

function make2D(r, c, v = 0) {
  const a = new Array(r);
  for (let i = 0; i < r; i++) a[i] = new Array(c).fill(v);
  return a;
}

function hashGrid(G) {
  // è»½é‡ãƒãƒƒã‚·ãƒ¥ï¼ˆç”Ÿå­˜ã‚»ãƒ«ã®æ•°ã¨ç°¡æ˜“xorï¼‰
  let count = 0, xor = 0;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (G[y][x]) {
        count++;
        xor ^= (x * 73856093) ^ (y * 19349663);
      }
    }
  }
  return count + ":" + xor;
}

function placeGosper(G, ox, oy) {
  const cells = [
    [0,4],[0,5],[1,4],[1,5],
    [10,4],[10,5],[10,6],
    [11,3],[11,7],
    [12,2],[12,8],
    [13,2],[13,8],
    [14,5],
    [15,3],[15,7],
    [16,4],[16,5],[16,6],
    [17,5],
    [20,2],[20,3],[20,4],
    [21,2],[21,3],[21,4],
    [22,1],[22,5],
    [24,0],[24,1],[24,5],[24,6],
    [34,2],[34,3],
    [35,2],[35,3]
  ];
  for (const [dx, dy] of cells) {
    const x = ox + dx, y = oy + dy;
    if (y >= 0 && y < rows && x >= 0 && x < cols) G[y][x] = 1;
  }
}

function createUI() {
  const container = createDiv().style('margin-top', '8px');
  sliderUPS = createSlider(minUPS, maxUPS, ups, 1).parent(container);
  sliderUPS.style('width', '240px');
  labelUPS = createSpan(`é€Ÿåº¦ï¼š${ups} ä¸–ä»£/ç§’`).parent(container);
  createSpan('ã€€').parent(container);
  btnPlayPause = createButton('â¯ å†ç”Ÿ/ä¸€æ™‚åœæ­¢').parent(container);
  btnPlayPause.mousePressed(() => {
    running = !running;
    if (!running) accumulatorMs = 0;
  });
  createSpan(' ').parent(container);
  btnStep = createButton('â¡ 1ä¸–ä»£é€ã‚Š').parent(container);
  btnStep.mousePressed(() => {
    if (running) running = false;
    const changed = stepOnce();
    labelStatus.html(changed ? "" : "ğŸŸ¢ é™æ­¢çŠ¶æ…‹ã«åˆ°é”");
  });
  createSpan(' ').parent(container);
  btnReset = createButton('ğŸ—˜ ãƒªã‚»ãƒƒãƒˆ').parent(container);
  btnReset.mousePressed(() => {
    initGrids();
    placeGosper(grid, 20, 20);
    running = true;
    labelStatus.html("");
  });
  createElement('br').parent(container);
  labelGen = createSpan(`ä¸–ä»£ï¼š${generation}`).parent(container);
  labelGen.style('font-weight', 'bold');
  createElement('br').parent(container);
  labelStatus = createSpan('').parent(container);
  labelStatus.style('color', '#007700');
  labelStatus.style('font-weight', 'bold');
}

function keyPressed() {
  if (key === ' ') {
    running = !running;
    if (!running) accumulatorMs = 0;
  } else if (key === 'N' || keyCode === RIGHT_ARROW) {
    if (running) running = false;
    const changed = stepOnce();
    labelStatus.html(changed ? "" : "ğŸŸ¢ é™æ­¢çŠ¶æ…‹ã«åˆ°é”");
  } else if (key === 'R' || key === 'r') {
    initGrids();
    placeGosper(grid, 20, 20);
    running = true;
    labelStatus.html("");
  }
}

